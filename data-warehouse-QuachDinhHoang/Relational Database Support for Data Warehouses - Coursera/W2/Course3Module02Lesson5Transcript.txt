Welcome to lesson five of module
two in the SQL subtotal operators. Let's finish our fun with subtotal
operators learning some neat tricks. I'm gonna start with
an important usage question that I want you to think
about throughout this lesson. When should you use variations
of subtotal operators? Lesson five concludes your
study of subtotal operators from lessons two to four. Lesson five covers interesting
variations of subtotal operators including partial cube and
rollup operations, composite columns, nested subtotal operations,
and subtotal identifiers. You can extend your understanding
of subtotal operations through these variations. You have three learning
objectives in this lesson. Your primary objective is to stretch
your understanding of subtotal operators to study of these variations. It's a more concrete goal. You should be able to list subtotal
groups, generally by subtotal variations. It's a more reflective goal. You should think about the complexity and importance of subtotal
operator variations. The cube, rollup and grouping sets
operators presented in lessons two to four, provide a solid foundation
for subtotals in the group by clause. The SQL standard provides more
flexibility in combining the operators. This flexibility can be useful
in specialized situations. This lesson, provides examples
of some of the variations that can be useful in
specialized situations. Partial cube and rollup operators
are a subset of grouping columns. Composite columns, to treat a combination
of columns as a single column. Nested cube and rollup operations,
inside the grouping sets operator, and usage of subtotal identifiers to indicate
the grouping level of result rows. A partial cube produces subtotals for
a subset of independent columns. For example,
the clause GROUP BY TimeMonth, CUBE(DivId, StoreZip) produces subtotals
into subtotal groups. The combination of TimeMonth,
DivId, StoreZip, the combination of TimeMonth and
DivId, the combination of TimeMonth, StoreZip, and
the combination of TimeMonth alone. TimeMonth concatenates with each subtotal
group generated by the CUBE operator. For example, TimeMonth concatenates
with the grand total group that is empty parentheses generated
by the cube operator so that the last subtotal group
contains TimeMonth, alone. I will now execute this statement
using the Oracle SQL Developer. The result contains 32 rows
of four columns in each row. The last row in each subtotal
group contains a TimeMonth summarized across all divisions and
zip codes. A partial rollup produces subtotals for a
subset of hierarchically related columns. For example, the clause
GROUP BY StoreState, ROLLUP(TimeMonth, TimeDay) produces total
in the subtotal groups. The combination of StoreState,
TimeMonth, TimeDay. The combination of StoreState and
TimeMonth. The StoreState by itself. StoreState, concatenates
with each subtotal group, generated by the ROLLUP operator. For example, StoreState concatenates
with the grand total group, that is the empty parentheses,
generated by the rollup operator, so that the last subtotal group
contains StoreState by itself. I will now execute this statement
using the Oracle SQL Developer. The result contains 18 rows
with four columns in each row. The last row in each subtotal group contains a StoreState summarized
across all months and days. Composite columns can be used
with a cube of rollup operators to skip some subtotal groups. For example, the clause,
GROUP BY ROLLUP(StoreNation, (StoreState, StoreCity) produces
totals on the subtotal groups. The combination of StoreNation,
StoreState, and StoreCity,
StoreNation by itself in the empty set. The rollup operation skips the subtotal
group, a combination of StoreNation and StoreState because the composite column, the combination of StoreState and
StoreCity, is treated as a single column. I will now execute this statement
using the Oracle SQL Developer. The result contains six rows,
with four columns in each row. Note that the results do
not have subtotals for the combination of StoreNation and
StoreState. Nesting the cube or rollup operation,
inside a grouping sets operation, generates different subtotals that
a partial cube or rollup operation. As previously shown, a partial CUBE or ROLLUP operation concatenates
with the other group by columns. In contrast, concatenation does
not occur when nesting a CUBE or ROLLUP operation inside
a grouping sets operation. This example uses a nested ROLLUP
operation with a composite column. The GROUP BY clause
generates subtotals for the combination of StoreNation, StoreState
and StoreCity, StoreNation by itself, and the grand total, that is,
the empty subtotal group for the nested ROLLUP operation and TimeMonth
subtotals for the GROUPING SET operation. TimeMonth does not concatenate
with a rollup subtotals. I'll now execute this statement
using the Oracle SQL Developer. The result contains ten rows
with five columns in each group. The sorting order shows
the time of totals, followed by the rollup subtotals with
the grand total in the last row. Sometimes, it is useful to
distinguish subtotal groups. The grouping ID function,
generates a hierarchical group number for each result row. For example, a cube of three columns
generates eight subtotal groups. The grouping ID function
using the cube columns labels rows with a number
from zero to seven. Other functions are group ID to
identify duplicate subtotal rows in a grouping function to distinguish
normal group by rows as given a value zero some subtotal rows given a value of one. This select statement show as a grouping
ID function using three columns. It is typical to include all grouping
columns in grouping ID function, although not necessary. The grouping ID function labels each
row with a grouping number from 0 to 7. With zero for the finest level of totals,
that is the combination of StoreZip, TimeMonth and DivId, and
seven for the grand total. The order by provides
sorting by grouping ID to cluster rows with
the same subtotal group. I will now execute this statement
using the Oracle SQL Developer. The result contains 40 rows
with 5 columns in each row. The sorting order shows a normal
group by rows with zero for the grouping level and the grand total row
with the maximum grouping level of seven. To extend your understanding
of the subtotal variations, you should work additional problems. A document in module two contains
solutions for these problems. This lesson completed the presentation
of SQL subtotal operators from lessons two to four. You learned about variations of the
subtotal operators providing flexibility beyond the basic cube, rollup and
groupiing sets operators. Lesson five covered partial cube and
rollup operations, composite columns, nested cube and rollup operations and
functions to identify subtotal groups. These variations are complex and
specialized so you use them with caution. In answer to the opening question,
subtotal variations are specialized so actual uses are not easy to identify. The grouping sets operator provides
complete control of subtotal rows so these variations do not
provide additional control. However, the variations allow
more compact specification in the grouping sets operator when
complete CUBE and ROLLUP are not needed. Beyond these specialized situations you
can use these variations to confuse and amuse your co-workers. If you understand these variations you
have a solid understanding of the SQL subtotal operators.